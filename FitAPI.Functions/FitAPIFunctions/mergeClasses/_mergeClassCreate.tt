<#@ template language="C#" debug="True" #>
<#@ output extension="cs" #>
<#@ include file="T4Toolbox.tt" #>
<#@ assembly name="Microsoft.SqlServer.ConnectionInfo" #>
<#@ assembly name="Microsoft.SqlServer.Management.Sdk.Sfc" #>
<#@ assembly name="Microsoft.SqlServer.Smo" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>

<#@ import namespace="Microsoft.SqlServer.Management.Smo" #>
<#
// <copyright file="_mergeClassCreate.tt" company="Mark Stacey">
//  Copyright Â© . All Rights Reserved.
// </copyright>
var server = new Server(".\\SQL2017");
    var database = new Database(server, "FitBI");
    database.Refresh();

#>
<#
    foreach (Table tTable in database.Tables)
    {
		if ( (tTable.Schema == "Exercise" || tTable.Schema == "Program" || tTable.Schema == "Stats")
		) {
			string fileName = tTable.Name;
			var lt = new ValuesTemplate(tTable, fileName);
			lt.RenderToFile("merge" + fileName + ".cs");
		}
    }
#>
<#+
private class ValuesTemplate : Template
{
    public ValuesTemplate(Table pTable, string className)
    {
        string strFile  = @"
using System.Linq;
using System.Net;

using System.Data;
using Microsoft.Data.SqlClient;

using Dapper;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Azure.Functions.Worker.Http;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;
using FitAPIFunctions.Schema;
using System.Collections.Generic;


namespace FitAPIFunctions
{
    public class merge" + className + @"
    {
        private readonly ILogger<merge" + className + @"> _logger;

        public merge" + className + @"(ILogger<merge" + className + @"> logger)
        {
            _logger = logger;
        }
	    [Function(""merge" + className + @""")]
        public async Task<HttpResponseData> Run([HttpTrigger(AuthorizationLevel.Function, ""get"", ""post"", Route = ""merge/" + className + @""")]HttpRequestData req)
		{

            var postData = await req.ReadAsStringAsync();

            var container = JsonConvert.DeserializeObject<FitAPIFunctions.Schema." + className + @"Container>(postData);

		_logger.LogInformation(""C# HTTP trigger function processed a request."");
            var sqlConnectionString =
                Environment.GetEnvironmentVariable(""FitDB_conn"")!;
            string JSON = ""Running API call"";
            HttpStatusCode statusCode = HttpStatusCode.OK;
            try
            {
			using (SqlConnection conn = new SqlConnection(sqlConnectionString))
                {
                    conn.Open();
                    conn.Execute(""API.merge_" + pTable.Schema  + "_" + pTable.Name  + @""",
                    new
                    {
                        tvp_" + pTable.Name  + @" = container." + pTable.Name  + @".AsTableValuedParameter(""" + pTable.Schema  + @".tvp_" + pTable.Name  + @"""
					, new List<string>(new string[] {";
		var sorted = (from Column o in pTable.Columns orderby o.Name select o).ToList();
		int iLoop = 0;
		foreach (Column cColumn in sorted)
		{
			strFile +=  (iLoop == 0 ? "" : ",") + @" """ + cColumn.Name + @"""";
			iLoop++;
		}
		strFile += @" })
					)
                    },
                    commandType: CommandType.StoredProcedure);
                }
		}
            catch (System.Exception ex)
            {
				JSON = ""Error occurred"";
                _logger.LogError(ex, ""C# HTTP trigger function encountered an error "");
                statusCode = HttpStatusCode.InternalServerError;

            }
            //Always return to not leave the client hanging
            var response = req.CreateResponse(statusCode);
            response.Headers.Add(""Content-Type"", ""application/json; charset=utf-8"");
            await response.WriteStringAsync(JSON);
            return response;
		}
	}
}
	";
	this.FileName = strFile;
    }
    private string FileName {get; set;}
    public override string TransformText()
    {
        #><#=this.FileName#><#+
        return this.GenerationEnvironment.ToString();
    }
}
#>
